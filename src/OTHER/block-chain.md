#### 币加索的区块链时光

hash 碰撞 collsion resistance

sha256 算法【比特币采用的哈希算法】

md5 可逆吗【md5 现在被认为是不够安全的 可以人为地制造 哈希碰撞】

公私钥对（非对称加密 跟我们 GIT 产生的 ssh-key 是同一个原理）

创世块

全节点 轻节点（只包含块头）

**hash 指针**

**merkle tree**（block body 所有交易记录哈希值相互形成的哈希金字塔）

**merkle proof** （验证 block body 中某个具体交易需要用到的主块会提供一串**merkle tree** 标识该交易的路径哈希组 通过交易的哈希 **+** merkle proof 计算结果 与 root hash 对比）

如果手机上只展示一个轻节点 怎么证明它是某个全节点 向全节点请求 merkle proof 梯级的 hash 一步步取 hash 跟 root hash 来对比

**merkle proof** 就是用来证明 某个交易（轻节点）被写入区块链了

**hash tree**

**block header**

**block body**

#### 怎么设计一套 数字货币

假设是央行（不使用区块链）

假设我的账户里有 100 块 带着央行的私钥签名 （公私钥体系）

问题： 数字货币的复制

那加一个唯一标识呢

#### 去中心化加密货币需要应对的两个问题

- 谁有权发行货币

- 如何验证交易的真实性

分布式的账本共识 怎么获取账本到本地

全局 hash 表

分布式共识中的不可能结论

impossibity result

asynchronous faulty

CAP theorem 分布式

C Consistant 一致性 (Paxos)

A Availability

P Partition toleration

#### bitcoin 中的共识协议

到底中间的这个交互是怎么做的呢

投票 membership 联盟链 hyperledger fabric

但比特币的账户就是一个公私钥对 不是普通的 membership

#### 女巫攻击

H(block header) <= target

nonce (4 bytes)

算对了随机数就有权利把你打包的区块写入到区块链

区块的合法性

最长合法链（分岔攻击 通过中间插入来回滚某个交易）

合法的分岔 等长链

orphan block

#### 出块 铸币交易

coinbase transaction (发行比特币的唯一方法)

比特币的数量上限

50BTC (21w) => 25BTC (21w) => 12.5BTC (21w) => 减半

21 万个区块大概需要 210000 \* 10 / 60 / 24 / 365 = 4 年

现在是 12.5

为什么记账权要靠算力

hash-rate

挖矿 mining 矿工 miner 争夺记账权 数字黄金 computational puzzle

#### 比特币系统的实现

**UTXO**数据结构

**double spending**

节点怎么决定打包哪些交易

交易费 **transaction reward**

概率论

每次开始新的挖矿 processor free 这跟从整体上感知一个挖矿的结果是不冲突的

如果别人发布了新的区块 大部分节点会先验证交易的合法性 如果不合法就还是按照上一个节点继续挖矿 否则的话校验新的交易记录 重新生成一个块再重新挖

**bitcoin is secured by mining**

是哪个傻逼提过比特币是`抵御人工智能的最后一道防线`

**self mining**

**forking attack**

`6次确认`（铸币交易应该也需要吧 不然系统不可能凭空让你消失 12.5 个比特币）

只要算力足够强 就可以制造出最长链 回滚交易记录 但 6 次基本算强度溢出了 现实交易中一些商家认为 `4次确认` 就可以发货了

#### 比特币网络的工作原理

the bitcoin metwork

比特币只是应用层 application layer bitcoin block chain

底层的原理是 p2p 网络 network overlay layer

所有节点对等 不存在 super node 或者 master node

但是有种子节点

其原则为 simple robust but not efficient

每个节点维护一个等待上链的交易集合（先看作是还没写到区块链中的交易吧）

假设 A-B A-C 用的是同一个交易 如果几乎是同时发出的 出于网络原因 不同的节点先收到的交易不同

每个区块 1M 大小限制 p2p 网络比较费带宽

best effort

交易发出去 某些节点没收到怎么办

比特币的交易回滚必须靠算力制造更长的链来实现

但是如果你付给商家比特币 商家不发货怎么办呢 那没办法 这是属于线上跟线下的问题了 区块链系统是无法解决的 只有你去联系商家 让他把比特币转回给你 产生新的交易记录

这跟现有支付体系其实是一样的

#### 交易是怎样被打包进区块的

来简单理解整合一下

比特币的本地数据存储体系主要分两部分

一部分是不可更改的**blockchain**

另一部分是网络相关信息**chainstate** 而这个 chainstate 主要就是用来保存通过网络广播或点对点请求的数据 不过既然是 state 数据 就是可变的

比如原本 chainstate 里面保存着一条交易记录 但是当该交易被打包进区块链并被确认之后 就可以从 chainstate 数据中删除了。

chainstate 里面保存着自己本机客户端的信息 也保存着网络中其他客户端发过来的信息 如果由于网络或机器原因 chainstate 数据丢失了 就需要通过其他节点进行恢复。

chainstate 在本地客户端是以**leveldb**作为底层数据库的。这个就真不懂了 具体可以参考这篇文章 https://baya.github.io/2017/09/04/build-our-btc-system.html

矿工首先是收集要创建区块的各种信息 会从本地的 chainstate 中挑选出部分交易出来 挑选出多少条由自己的算法决定

但整个区块的容量不超过 1M 对这些交易按照特定顺序排列后做 merkle 得到的 merkle hash root 和其他信息如时间戳、nonce 等一起进行求区块 hash 的运算

得到合理的 hash 之后 就可以把所有这些东西组装在一起 按照比特币的数据存储结构算法生成比特币内部的区块文件 着就是一个区块了。

所以 在一个区块没有产生之前 这些交易数据是保存在 chainstate 里面的

#### 挖矿的过程

挖矿难度越大 目标阈值越小

怎么调整挖矿难度 谁来调整 谁去调查现有的总算力是多少

为什么要根据总算力来调整挖矿难度

因为如果不调整 平均挖出一个快仅需 1 两分钟甚至几十秒钟的话 如果有多个节点同时挖到区块并发布 而 p2p 网络广播到大部分节点本身就需要数十秒的时间 就会导致很多节点收到不同的区块且又在不同区块的基础继续开挖 从而导致很多分叉

导致很多分岔又会怎样呢 显然这样会导致总算力被分散不同的链分支上面 从而最长链的长度长的越来越慢 这个时候 某些恶意节点可能就不要掌握 51%的总算力就可以轻松的实现分岔攻击了

但是对于一个支付系统来说 10 分钟是不是太长了 以太坊是怎么做到 15 秒的呢

在**以太坊**中 那些被最长链丢弃的合法区块叫做 **orphan block** 孤儿区块

这些块仍然可以获得区块奖励： **uncle reward**

相同点是 都需要调整区块难度 是的出块时间稳定

比特币中 每 2016 个区块 调整一次挖矿难度 大约 14 天

也就是 target = target \* 实际时间 / 理论时间 （难度调整上下不超过 4 倍）

即不管实际时间是多少 也要限制在一定区间

如果算力越来越强 难度越来越大

难度写在比特币的源代码（开源）里 块的头信息 block header 中

由 nbits 协议版本号来体现

以太坊中难度的调整复杂的多

有没有想过这些阈值 10 分钟、2016 个 是否合理 是否最优

全节点跟轻节点的区别

全节点会在本地保留一份完整的区块链交易数据

一般的转账运行一个轻节点就可以了吧

一旦收到别人发布通知了 第一时间除了验证块的合法性

还有就是放弃已有的挖矿 重新生成一个区块

比特币的共识机制

CPU

GPU 处理大量通用并行计算

ASIC 芯片 Application Specific Integrated Circuit

一种为专门目的而设计的集成电路

只为单一币种挖矿 因为每个币种的 mining puzzle 都不一样

ASIC 矿机生命周期短

等同于“军备竞赛”

引入一个概念

可替代性的 mining puzzle 抗 ASIC 化 老百姓也能挖矿

现在个人的 ASIC 挖矿几乎等同于买彩票 收入不稳定

矿池的出现

pool manager ---- many miner

矿主负责跟链打交道 负责制定挖矿程序 监听其他节点发布区块 打包候选区块

矿工只负责计算哈希值 根据（算力）工作量从矿主那里抽取分成

矿主通过什么算法给矿工分红呢

如果目标要挖 70 个零 一个矿工挖到 70 个零就成功了

有的矿工只挖到 60 个零 有的只挖到 64 个零 零越多证明你工作越多（大体上 当然有微乎其微的运气成分）他可以把这些变量提供给矿主 虽然对矿主来说没什么用 但这是分红的凭据

矿工有可能在挖到区块后不提交给矿主而自己偷偷发布吗

不会 因为矿工只贡献算力 组装的区块是矿主提供的 里面的 coinbase 填的是矿主的地址

派遣恶意矿工去竞争对手的矿池挖矿 挖到矿却不提交给矿主

#### 挖矿机制的两种形式

**POW**

proof of work 基于工作量 谁算力强 谁就牛逼

**POS**

proof of stake 基于权益 谁的权益（代币、钱）多 谁就掌握记账权 （联盟链的基石？）挖矿的哈希不等式会改变

容易造成马太效应（正态分布的对立面）

两者的哈希不等式有什么不同

#### 比特币脚本的几种形式

输入脚本跟输出脚本

每个交易都有输入输出 每次校验是先把当前交易的输入脚本提出来 再把输入来源的那个交易的输出脚本提出来一起执行 能通过则该交易合法

- P2PK

- P2PKH（最常用）

- P2SH 多重签名的形式

**看下 P2PKH（最常用的一种）**

```bash
#输入脚本（付款方在本交易中的输入）包含
pushdata(付款方的私钥签名)   #签名入栈
pushdata(付款方的公钥)      #公钥入栈
#输出脚本（要转给那些人）包含
dup                #栈顶复制一遍 即付款方的公钥复制再入栈
hash160            #栈顶弹出 取哈希再入栈 两步连起来就是入栈公钥的哈希
pushdata(收款方的公钥哈希) #收款人的公钥哈希入栈
equalverify        # 弹出栈顶的两个哈希对比 相同则
checksig           # 弹出栈顶的公钥跟签名验证 通过则压入true
```

这里有问题啊 equalverify 为什么要对比这两个哈希值呢 他们是不同的公钥取的哈希 这能相等？没错 就是这样！别忘了这不是同一个交易中的输入输出 而是付款方来源的输出 pushdata(收款方的公钥) 这一步指的是付款方在他的上一笔交易中的输出 两个公钥理应是同一个 为了防止输入脚本的公钥替换成别人的

整个过程跟收款方并没有联系 而是为 了证明本次交易付款方能不能够付款 他的币来源能不能对上 是 spending 的过程

**比较复杂的一种 （pay to script hash）**

这一种首先区别是**交易输出**

输出的不是收款人的公钥哈希 而是一段脚本的哈希

这段脚本叫 redeemscript 赎回脚本 将来的收款方用这些钱的时候 需要提供这个脚本的具体内容并要能够正确运行

那输入呢？

需要输入一些签名（为什么是一些）一段序列化的脚本

怎么验证呢？

```bash
# redeemScript的内容
pushdata(付款方公钥)
checksig # 检查签名

# input
pushdata(付款方签名)             #1
pushdata(序列化好的付款方的脚本)   #2

# output
hash160                        #3
pushdata(反序列化的付款方的脚本)   #4
equal                          #5

验证过程
（第一阶段：验证脚本内容）
1 pushdata(sig)      #签名入栈
2 pushdata(seriRS)   #序列化脚本入栈
3 hash160            #上面序列化的脚本弹出取哈希并入栈
4 pushdata(seriRSH)  #输出的脚本哈希入栈
5 equal              #对比两个哈希值是否相等
（第二阶段：验证脚本执行）
节点会把脚本反序列化
1 pushdata(付款方公钥)
2 checksig # 检查签名
```

这跟最常用的 P2PH 有什么更好的吗？

为了**多重签名** 什么意思呢

假设我和另外 4 人合伙开公司 每一笔的花费都需要经得 3 人以上的同意

那么最少要三人签名才能通过 那么这个怎么处理付款时候签名的灵活性呢？

先看看以前的多重签名是怎么做的：

客户给我们转账的时候 在输出脚本中我们需要给到：

```bash
#哪几个人签名
pushdata(sig1)
pushdata(sig2)
#需要签名的最少数量
2
#一组公钥
pushdata(pubkey1)
pushdata(pubkey2)
pushdata(pubkey3)
#公钥的数量
3
checkmultisig
```

这样签名入栈跟公钥入栈放在一起就固定了 付款的时候还不能改 而且暴露给客户了 我们公司收着这款时谁同意了谁不同意

看下现在的**P2SH**的情景 是把 pushdata(pubkey)跟 pushdata(sig)分开了

在输出 redeemScript 赎回脚本中给出 5 个人的公钥及 M 跟 N

在输入脚本中 按顺序输入签名

**Proof of Burn** ————花不出去的币（这种币在 UTXO 中可以直接剔除）

如果输出含有 RETURN 语句 那么输出脚本会立即返回 false 也不再执行后面的语句

为什么要写入这种脚本

- 为了比特币的销毁 比如在某些特定的情况下说你要用比特币去换一些其他的币种**altcoin** 销毁一些比特币证明你付出了代价

- 比如说你可以往区块链写入一些永久的东西 因为**return**语句的后面可以填写其他任意的内容 你可以把一段预言取哈希存进去 然后几十年后你可以把预言公布出来说明你以前就预言到了

- **coinbase** 铸币交易中其实也可以实现这个功能 但 coinbase 必须要你发布区块才能记 但绝大部分人是挖不到区块的 但是这种不同 普通用户只要销毁一丢丢比特币（甚至不需要销毁比特币 转账金额全部用来做小费 fees 奖励给矿工）就能往里面写东西

以上就是比特币的脚本语言 算是非常简单的了 像以太坊中的智能合约 会复杂的多

支持循环等操作 图灵完备 表达能力很强

#### 比特币系统中的分岔

前面的理解中对分岔已经有很强的概念了

**fork   state fork   forking attack   deliberate fork**

由于比特币协议升级造成的分岔 某些节点来不及或不同意升级造成的 协议分岔 **protocal fork**

protocal fork 中又分成 hard fork 跟 soft fork

- **hard fork**   某些节点不同意新协议中某些新功能（ **new feature**）

比如说比特币中区块的大小限制

1M 够不够用 交易的延迟太长了怎么办 100 万个字节才多大 最多能容纳 4000 个左右的交易 算下来每两秒钟 7 笔交易

这要是线下都用比特币付款 按中国这个体量 怎么扩容呢 不用担心这个问题吗

如果有人提出了新的协议 block size 1M ==> 4M

如果本来是一兆一兆的链突然来一个 4 兆的 那这...旧节点（假设是小部分节点）就不认可 他们会沿着前一个 1 兆的区块继续挖 开一个分支

大部分新节点会认可 4 兆的区块 当然也认可旧节点的小区块

```bash
 1   2   3   4   5   6   7
>1---1---1---4---4---2---4  #新分支 新节点认可的
         |
         ----1---1  #旧分支 旧节点认可的 新节点虽然也认可但是ta不够长
#只要旧节点只要不升级协议 那就算它最长那也是不合法的
```

那么这就是一个一硬分岔 那这这这...咋收场呢 假设新旧节点数量像相当 那就真的变成平行世界了 两个阵营打架 你挖你的 我挖我的 两条分链上的币相互不认 分岔以前的则不影响 在各自的阵营中视对方链为不合法 这在以太坊中是真实存在的事情 本来是 ETC 后来在新链 ETH 上了

那现在问题来了：如上图 1 到 7 这个高度（块的先后）

如果第一个块 A 转 B 10 块 那 B 有 10 块了对吧 那么在第四个块 新链上 B 转 C10 块 然后在用旧节点登陆 B 的账户 这时候 B 的 10 块是没有被花出去的 因为新链上的块不合法 他不认 那么他又可以给 C 转 10 块 这不乱套了吗 这在以太坊中也是真实存在过的

所以后来每个交易都会加上一个 chainID 这样同一个账户在不同的分支上会保持不同的余额 也不能向另一个分支的账户转账

- **soft fork** 那么软分岔呢

假设是从 1M 变成 0.5M 会怎么样

你品。。细品。。。 结果是不是就完全不一样了 会造成一种临时性的分岔 最后旧节点会被迫更新到新节点上面去 当然这个结果的前提是超过半数以上的节点都支持新节点的情况下。【当然这种 block-size 变小的情况只是举个例子】

实际上比特币历史上著名的软分岔就是 **P2SH** pay to script hash

早起版本的比特币协议 是没有这个的

总结下来就是：

**soft fork**    只要半数以上算力的节点都更新了协议 那么就不会出现永久的分岔 其他不想更新的节点会被迫更新

**hard fork**   只有百分百节点都更新了协议 区块链就不会出现永久性的分岔

#### 插入一些问题：

- UTXO 的形成一个跟哈希 填到 coinbase 域里有什么用？

- 比特币交易中收款方不在线怎么办？

收款方不需要在线 收款方事先提供相关信息即可 并不需要他干嘛

- 在转账交易的时候有没有可能转给一个不存在的用户

有可能 一个账户的生成就是一对秘钥 并不会通知其节点 系统也没有办法证明某个公钥不是一个有效的用户 但是可以知道它有没有交易记录

- 如果一个账户的私钥丢失了那该怎么办（不是泄露了）

没有办法 秘钥丢失你账户里的钱就是死钱了 耶稣也救不了你 但是这只是从系统的角度来看 实际情况中不会存在这种情况 因为现实中交易所是一个中心化的机构 你在交易所的账户会绑定你的身份 交易所会帮你保存你的私钥 但交易所也不是绝对安全的 比特币的交易所缺乏监管 也有可能被黑

如：门头沟事件（**mt.gox** Magic:the Gathering Online Exchange）85w 比特币被盗（不是丢失）

如果某些账户私钥丢失 转给这些账户的钱会永久存在 UTXO 集合里面

- 比特币被盗追得回来吗

好像追不回来诶 因为比特币的透明性跟匿名性

- 如果你的私钥泄露了怎么办（如果你发现你的账户有可疑的交易记录）

资金转移

- 如果转账转错人了（或者转到一个不存在的账户）怎么办

没有办法 地址只是公钥的哈希值 系统也不知道这谁的 是不是有效的

#### digital commitment

花一点比特币获取一个将一段哈希写入区块链的机会

这里再引申一下 proof of burn 中的 op_return

如果一个全节点在 UTXO 集合中收到一个带有 return 语句输出脚本的交易 全节点在打包候选区块的就不能检测一下输出脚本的能不呢执行通过吗？

这又回到比特币脚本了 全节点在打包这个交易的时候 执行的是本次交易的输入脚本 **+** 上次交易的输入脚本 故本次交易的输出脚本是不会执行到的

#### 比特币的匿名性

**anonymity**（区分于**privacy**）这里的匿名性不是没有名字 而是化名

在以前银行开户居然真的不需要实名制 有存折就能取钱

我们来分析下比特币的匿名性到底怎么样

- 化名 不需要实名制

- 根据交易的地址查不到这个人的真实身份

- 一个自然人可能会有多个地址 而且谁也不知道

看似匿名信很强了对吧    实际上可能并不是 因为以下几点

- 比特币的账本交易公开 每个地址的余额讲道理都能算出来

- 就算你有很多个地址 从交易中分析也极有可能将他们关联上 因为一笔交易中可能多个输入和多个输出 交易如果是你发起的 那么输入地址对应的所有私钥肯定都是在你手里的 另外输出中往往包含这找零的地址（可能会通过钱包生成） 这可能也是你的

- 最重要的一点是 不管你在比特币系统中有多匿名 如果你需要提现一笔比特币 那你还是要回归到线下来吧 比特币只是价值符号 不是一般等价物 你要买东西你把比特币付过去了 你还是要提供收款地址（即使你是代收）你想兑换成人民币你还是要提供账户

只要你跟线下联系了 很容易就能定位到真实的自然人 那为什么中本聪的匿名性做的那么好 因为他根本就不花钱

### [_Silk Road_](http://www.baidu.com/link?url=89AU9_-LgNGv5mwmsJrcfKesxz5WdRCo86ORstAI3wPL1VqqlwZgwHzZI5z0vhCXCTpLNNxjoxEK_BS3xEtYKF_1P7I4NLD2BoY5sqgZw1G)

比特币系统走上正规以后中本聪就消失了

#### 思考一些细节上的点

- 哈希指针

这里的哈希指针并不是我们内存中变量指针的意义 区块中的哈希指针说的是指向像一个区块 在实际的系统中 区块链的存储结构就是在 leveldb 中 通过 key-val 形式存起来的

- 区块恋的故事 多重签名完全优于私钥截断

#### 分布式共识

比特币怎么绕开的分布式共识中的不可能结论

**比特币并没有绕过理论上的分布式共识**
